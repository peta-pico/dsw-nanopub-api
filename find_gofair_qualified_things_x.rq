#+ summary: Find things (optionally of the given type) introduced in nanopubs with info about qualifications by GO FAIR, excluding nanopubs that have been retracted, superseded, or disapproved (the latter only by GO FAIR members)
#+ method: GET
#+ pagination: 10000

prefix np: <http://www.nanopub.org/nschema#>
prefix npa: <http://purl.org/nanopub/admin/>
prefix npx: <http://purl.org/nanopub/x/>
prefix xsd: <http://www.w3.org/2001/XMLSchema#>
prefix dct: <http://purl.org/dc/terms/>
prefix rdfs: <http://www.w3.org/2000/01/rdf-schema#>

select distinct ?thing ?label ?np ?date ?qualification_np where {
  graph npa:graph {
    ?np npa:hasHeadGraph ?h .
    ?np dct:created ?date .
    filter(str(?date) > "2022")
    ?np npa:hasValidSignatureForPublicKey ?pubkey .
  }
  graph ?h {
    ?np np:hasAssertion ?a .
    ?np np:hasPublicationInfo ?i.
  }
  graph ?a {
    ?thing a ?__type_iri .
    ?thing rdfs:label ?label .
  }
  graph ?i {
    ?np (npx:introduces|npx:describes) ?thing .
  }
  optional {
    graph npa:graph {
      ?newversion npa:hasHeadGraph ?nh .
      ?newversion npa:hasValidSignatureForPublicKey ?pubkey .
    }
    graph ?nh {
      ?newversion np:hasPublicationInfo ?ni .
    }
    graph ?ni {
      ?newversion npx:supersedes ?np .
    }
  }
  filter (!bound(?newversion))
  optional {
    graph npa:graph {
      ?retraction npa:hasHeadGraph ?rh .
      ?retraction npa:hasValidSignatureForPublicKey ?pubkey .
    }
    graph ?rh {
      ?retraction np:hasAssertion ?ra .
    }
    graph ?ra {
      ?somebody npx:retracts ?np .
    }
  }
  filter (!bound(?retraction))

  bind(concat(" ",lcase(str(?label))," ") as ?text)
  filter( contains(?text, lcase(str(?_searchterm))) )

  optional {
    graph npa:graph {
      ?disapproval npa:hasHeadGraph ?dh .
      ?disapproval npa:hasValidSignatureForPublicKey ?dpubkey .
    }
    graph <https://w3id.org/np/RAjx8HnBCHoVYIN6MqvdyWGxdB97XS9pmCSvXHu-1B7Sg#assertion> {
      ?dpubkeys npx:hasPublicKey ?dpubkey .
    }
    graph ?dh {
      ?disapproval np:hasAssertion ?da .
    }
    graph ?da {
      ?dsomebody ( npx:disapproves-of | npx:disapprovesOf ) ?np .
    }
  }
  filter (!bound(?disapproval))  # No idea why "filter not exists" above doesn't work...

  optional {
    graph npa:graph {
      ?qualification_np npa:hasHeadGraph ?qh .
      ?qualification_np npa:hasValidSignatureForPublicKey ?qpubkey .
    }
    graph <https://w3id.org/np/RAjx8HnBCHoVYIN6MqvdyWGxdB97XS9pmCSvXHu-1B7Sg#assertion> {
      ?qpubkeys npx:hasPublicKey ?qpubkey .
    }
    graph ?qh {
      ?qualification_np np:hasAssertion ?qa .
    }
    graph ?qa {
      ?qualifier npx:qualifies ?np .
    }
    filter not exists {
      graph npa:graph {
        ?qnewversion npa:hasHeadGraph ?qnh .
        ?qnewversion npa:hasValidSignatureForPublicKey ?qpubkey .
      }
      graph ?qnh {
        ?qnewversion np:hasPublicationInfo ?qni .
      }
      graph ?qni {
        ?qnewversion npx:supersedes ?qualification_np .
      }
    }
    filter not exists {
      graph npa:graph {
        ?qretraction npa:hasHeadGraph ?qrh .
        ?qretraction npa:hasValidSignatureForPublicKey ?qpubkey .
      }
      graph ?qrh {
        ?qretraction np:hasAssertion ?ra .
      }
      graph ?qra {
        ?qsomebody npx:retracts ?qualification_np .
      }
    }
  }
}
order by asc(?label)
